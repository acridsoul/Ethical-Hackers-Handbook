#    SPDX-FileCopyrightText: 2021 Daniel Fernandez Kuehr <daniel.kuehr@tacitosecurity.com>
#    SPDX-License-Identifier: GPL-3.0-or-later

import sys
import fuzzer
from code import Code

msrs = (
  0x00, 0x01, 0x10, 0x17, 0x1b, 0x20, 0x21, 0x28, 0x29, 0x2a, 0x2c, 0x34,
  0x3a, 0x3b, 0x40, 0x47, 0x48, 0x49, 0x4e, 0x4f, 0x60, 0x79, 0x8b, 0x8f,
  0x9b, 0x9e, 0xc1, 0xc2, 0xcd, 0xce, 0xe2, 0xe7, 0xe8, 0xfe, 0x107, 0x108,
  0x109, 0x10a, 0x10b, 0x10f, 0x110, 0x111, 0x112, 0x113, 0x114, 0x115, 0x116,
  0x117, 0x119, 0x11e, 0x120, 0x140, 0x174, 0x175, 0x176, 0x179, 0x17a, 0x17b,
  0x180, 0x181, 0x182, 0x183, 0x184, 0x185, 0x186, 0x187, 0x188, 0x189, 0x18a,
  0x198, 0x199, 0x19a, 0x19b, 0x19c, 0x19d, 0x1a0, 0x1a2, 0x1a4, 0x1a6, 0x1a7,
  0x1aa, 0x1ad, 0x1ae, 0x1af, 0x1b0, 0x1b1, 0x1b2, 0x1c8, 0x1c9, 0x1d9, 0x1db,
  0x1dc, 0x1dd, 0x1de, 0x1fc, 0x1ff, 0x200, 0x201, 0x202, 0x203, 0x204, 0x205,
  0x206, 0x207, 0x208, 0x209, 0x20A, 0x20B, 0x20C, 0x20D, 0x20E, 0x20F, 0x210,
  0x211, 0x212, 0x213, 0x214, 0x215, 0x216, 0x217, 0x218, 0x219, 0x21A, 0x21B,
  0x21C, 0x21D, 0x21E, 0x21f, 0x250, 0x257, 0x258, 0x259, 0x267, 0x268, 0x269,
  0x26a, 0x26b, 0x26c, 0x26d, 0x26e, 0x26f, 0x277, 0x280, 0x2ff, 0x300, 0x301,
  0x302, 0x303, 0x304, 0x305, 0x306, 0x307, 0x308, 0x309, 0x30a, 0x30b, 0x30c,
  0x30d, 0x30e, 0x30f, 0x310, 0x311, 0x345, 0x360, 0x361, 0x362, 0x363, 0x364,
  0x365, 0x366, 0x367, 0x368, 0x369, 0x36a, 0x36b, 0x36c, 0x36d, 0x36e, 0x36f,
  0x370, 0x371, 0x38d, 0x38e, 0x38f, 0x390, 0x391, 0x3a0, 0x3a1, 0x3a2, 0x3a3,
  0x3a4, 0x3a5, 0x3a6, 0x3a7, 0x3a8, 0x3a9, 0x3aa, 0x3ab, 0x3ac, 0x3ad, 0x3ae,
  0x3af, 0x3b0, 0x3b1, 0x3b2, 0x3b3, 0x3b4, 0x3b5, 0x3b6, 0x3b7, 0x3b8, 0x3b9,
  0x3ba, 0x3bb, 0x3bc, 0x3bd, 0x3be, 0x3bf, 0x3c0, 0x3c1, 0x3c2, 0x3c3, 0x3c4,
  0x3c5, 0x3c8, 0x3c9, 0x3ca, 0x3cb, 0x3cc, 0x3cd, 0x3e0, 0x3e1, 0x3f1, 0x3f2,
  0x3f6, 0x3f7, 0x3f8, 0x3f9, 0x3fa, 0x3fc, 0x3fd, 0x3fe, 0x3ff, 0x400, 0x401,
  0x402, 0x403, 0x47f, 0x480, 0x481, 0x482, 0x483, 0x484, 0x485, 0x486, 0x487,
  0x488, 0x489, 0x48a, 0x48b, 0x48c, 0x48d, 0x48e, 0x48f, 0x490, 0x491, 0x4c1,
  0x4d0, 0x560, 0x561, 0x570, 0x571, 0x572, 0x580, 0x581, 0x582, 0x583, 0x584,
  0x585, 0x586, 0x587, 0x600, 0x606, 0x60a, 0x60b, 0x60c, 0x60d, 0x610, 0x611,
  0x613, 0x614, 0x618, 0x619, 0x61b, 0x61c, 0x630, 0x631, 0x632, 0x633, 0x634,
  0x635, 0x638, 0x639, 0x63a, 0x63b, 0x640, 0x641, 0x642, 0x648, 0x649, 0x64a,
  0x64b, 0x64c, 0x64d, 0x64e, 0x64f, 0x658, 0x659, 0x65a, 0x65b, 0x660, 0x664,
  0x668, 0x669, 0x66a, 0x66b, 0x66c, 0x66d, 0x680, 0x690, 0x6b0, 0x6b1, 0x6c0,
  0x6e0, 0x770, 0x771, 0x772, 0x773, 0x774, 0x777, 0x830, 0x831, 0x83f, 0xd90,
  0xda0, 0xdc0, 0xffc, 0x1107, 0x110a, 0x110b, 0x1147, 0x1900, 0x18000000,
  0x80868010, 0x80868011, 0x80868018, 0x8086801a, 0xc0000080, 0xc0000081,
  0xc0000082, 0xc0000083, 0xc0000084, 0xc0000085, 0xc0000086, 0xc0000087,
  0xc0000088, 0xc00000e9, 0xc0000100, 0xc0000101, 0xc0000102, 0xc0000103,
  0xc0000104, 0xc0010000, 0xc0010001, 0xc0010002, 0xc0010003, 0xc0010004,
  0xc0010005, 0xc0010006, 0xc0010007, 0xc0010010, 0xc0010015, 0xc001001a,
  0xc001001b, 0xc001001d, 0xc001001f, 0xc0010020, 0xc0010041, 0xc0010042,
  0xc0010044, 0xc0010055, 0xc0010058, 0xc0010062, 0xc0010063, 0xc0010064,
  0xc0010112, 0xc0010113, 0xc0010114, 0xc0010115, 0xc0010117, 0xc001011f,
  0xc0010131, 0xc0010140, 0xc0010141, 0xc0010200, 0xc0010201, 0xc0010230,
  0xc0010231, 0xc0010240, 0xc0010241, 0xc0010280, 0xc001100c, 0xc0011019,
  0xc001101a, 0xc001101b, 0xc0011020, 0xc0011021, 0xc0011022, 0xc0011027,
  0xc0011029, 0xc001102a, 0xc001102c, 0xc0011030, 0xc0011031, 0xc0011032,
  0xc0011033, 0xc0011034, 0xc0011035, 0xc0011036, 0xc0011037, 0xc0011038,
  0xc0011039, 0xc001103a, 0xc001103b, 0xc001103d
)

def ROR(x, n, bits):
    return (x >> n) | ((x & ((2**n) - 1)) << (bits - n))

class Fuzzer(fuzzer.Fuzzer):
    def __init__(self, seed):
        super().__init__(seed)
        self.discovered_msrs = dict()

    def flip_bits(self, data, bits):
        bitlens = zip(*((x, (bits-x) ** 6) for x in range(1, bits)))
        mask = self.rand.getrandbits(self.rand.choices(*bitlens)[0])
        return data ^ ROR(mask, self.rand.randint(0, bits), bits)

    def fuzz(self, reply):
        if reply:
            msr, rdx, rax = reply

            if msr not in self.discovered_msrs.keys(): 
                print(f'New MSR:{msr:08x} -> rdx:{rdx:016x} rax:{rax:016x}')

            self.discovered_msrs[msr] = (rdx, rax)

        rdx = self.rand.randint(0, (1 << 64) - 1)
        rax = self.rand.randint(0, (1 << 64) - 1)

        if not self.discovered_msrs or self.rand.choice((True, False)):
            rcx = self.rand.choice(msrs)
        else:        
            rcx = self.rand.choice(list(self.discovered_msrs.keys()))

            if self.rand.choice((True, False)):
                rdx, rax = self.discovered_msrs[rcx]
                rdx = self.flip_bits(rdx, 64)
                rax = self.flip_bits(rax, 64)

        if self.rand.choice((True, False)):
            rcx = self.flip_bits(rcx, 32)

        op = self.rand.choice((
            f"""mov rcx, {rcx:#x}
                rdmsr
                PUT_VA UInt32, rcx, UInt64, rdx, UInt64, rax
                REPLY
            """,
            f"""mov rcx, {rcx:#x}
                mov rax, {rax:#x}
                mov rdx, {rdx:#x}
                wrmsr
                PUT_VA UInt32, rcx, UInt64, rdx, UInt64, rax
                REPLY
            """))
        code = self.code(self.context_save() + op + self.context_restore())
        self.guest.execute(code)

if __name__ == "__main__":
    Fuzzer(int(sys.argv[1])).run()
